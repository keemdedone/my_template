<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="click_drag.css" />
    <title>Document</title>
  </head>
  <body ng-app="myApp">
    <carousel></carousel>
  </body>
</html>
<script>
  (function (angular, Impetus) {
    angular
      .module("myApp", [])
      .directive("carousel", Carousel)
      .directive("carouselSlide", CarouselSlide);

    function Carousel() {
      return {
        scope: false,
        restrict: "E",
        replace: true,
        template:
          '<div class="carousel-container"><div class="carousel-wrapper"><div class="carousel-animator" ng-style="getAnimatorStyles()"><div class="carousel-slides-container"><carousel-slide ng-repeat="slide in slides" slide="slide" duplicate="before"></carousel-slide><carousel-slide ng-repeat="slide in slides" slide="slide"></carousel-slide><carousel-slide ng-repeat="slide in slides" slide="slide" duplicate="after"></carousel-slide></div></div></div></div>',
        link: function (scope, element) {
          scope.container = element;
          scope.wrapper = scope.container.children().eq(0);
          scope.animator = scope.wrapper.children().eq(0);
          scope.slidesContainer = scope.animator.children().eq(0);

          scope.animatorWidth = 0;
          scope.animatorPosition = 0;
          scope.animationRunning = false;

          scope.slides = [];

          scope.$watch(
            "slides",
            function () {
              if (scope.slides.length > 0) {
                _calcDimensions();
                _checkAnimationAllowance();
              }
            },
            true
          );

          scope.getAnimatorStyles = function () {
            return {
              width: scope.animatorWidth + "px",
              "margin-left": -(scope.animatorWidth / 2) + "px",
              transform: "translateX(" + scope.animatorPosition + "px)",
            };
          };

          function _animationStep() {
            if (scope.animationRunning) {
              _updateAnimatorPosition((scope.animatorPosition -= 0.25));
              scope.animationFrameRequest =
                window.requestAnimationFrame(_animationStep);
            }
          }

          function _startAnimation() {
            if (scope.animationFrameRequest) {
              _stopAnimation();
            }
            scope.animationRunning = true;
            scope.animationFrameRequest =
              window.requestAnimationFrame(_animationStep);
          }

          function _stopAnimation() {
            scope.animationRunning = false;
            if (scope.animationFrameRequest) {
              window.cancelAnimationFrame(scope.animationFrameRequest);
              delete scope.animationFrameRequest;
            }
          }

          function _getAnimationThreshold() {
            var wrapperWidth = scope.wrapper[0].getBoundingClientRect().width;
            return (
              (scope.animatorWidth - wrapperWidth) / 2 + scope.animatorWidth
            );
          }

          function _getPositionWithBounds(posX) {
            var animationThreshold = _getAnimationThreshold();
            if (posX > animationThreshold) {
              posX = posX - scope.animatorWidth;
            } else if (posX < -animationThreshold) {
              posX = posX + scope.animatorWidth;
            }
            scope.impetus.setValues(posX, 0);
            return posX;
          }

          function _updateAnimatorPosition(posX) {
            scope.$apply(function () {
              scope.animatorPosition = _getPositionWithBounds(posX);
            });
          }

          function _checkAnimationAllowance() {
            var animationAllowed = _isElementVisible(scope.container[0]);
            if (scope.animationRunning && !animationAllowed) {
              _stopAnimation();
            } else if (!scope.animationRunning && animationAllowed) {
              _startAnimation();
            }
          }

          function _isElementVisible(element) {
            var rect = element.getBoundingClientRect();
            var visible = {
              bottom: rect.top + rect.height >= 0,
              right: rect.left + rect.width >= 0,
              top:
                rect.bottom - rect.height <=
                (window.innerHeight || document.documentElement.clientHeight),
              left:
                rect.right - rect.width <=
                (window.innerWidth || document.documentElement.clientWidth),
            };
            return (
              visible.top && visible.bottom && visible.left && visible.right
            );
          }

          function _bindEvents() {
            scope.impetus = new Impetus({
              source: scope.wrapper[0],
              update: _updateAnimatorPosition,
            });

            scope.wrapper
              .bind("mouseenter touchstart", function () {
                scope.$apply(_stopAnimation);
              })
              .bind("mouseleave touchend", function () {
                scope.$apply(_startAnimation);
              });

            angular
              .element(window)
              .bind("scroll resize", _checkAnimationAllowance);
          }

          function _getChannelData() {
            scope.slides = [
              {
                poster: {
                  src: "https://images-na.ssl-images-amazon.com/images/M/MV5BMTczMDk1NDYyMV5BMl5BanBnXkFtZTgwNjE1NDU4MDI@.jpg",
                  alt: "The Walking Dead on AMC",
                },
                channel: {
                  name: "AMC",
                  logo: {
                    src: "http://vignette1.wikia.nocookie.net/logopedia/images/6/60/AMC_logo_2013.svg",
                    alt: "AMC Logo",
                  },
                },
              },
              {
                poster: {
                  src: "https://images-na.ssl-images-amazon.com/images/M/MV5BOTEzNzI3MDc0N15BMl5BanBnXkFtZTgwMzk1MzA5NzE@.jpg",
                  alt: "Vikings on History Television",
                },
                channel: {
                  name: "History Television",
                  logo: {
                    src: "http://vignette3.wikia.nocookie.net/logopedia/images/4/4d/History_Channel_logo.svg",
                    alt: "History Television Logo",
                  },
                },
              },
              {
                poster: {
                  src: "https://images-na.ssl-images-amazon.com/images/M/MV5BMjM0MDYzODA1MV5BMl5BanBnXkFtZTgwNDE5MTkxNDE@.jpg",
                  alt: "Justified on FX",
                },
                channel: {
                  name: "FX Canada",
                  logo: {
                    src: "http://vignette4.wikia.nocookie.net/logopedia/images/5/56/FX_international_logo.svg",
                    alt: "FX Canada Logo",
                  },
                },
              },
              {
                poster: {
                  src: "https://images-na.ssl-images-amazon.com/images/M/MV5BMTU0MDU1MzY4Nl5BMl5BanBnXkFtZTcwODM5ODk2Nw@@.jpg",
                  alt: "Duck Dynasty on A&E",
                },
                channel: {
                  name: "A&E",
                  logo: {
                    src: "http://vignette2.wikia.nocookie.net/logopedia/images/6/6a/A%26E_logo_2008.svg",
                    alt: "A&E Logo",
                  },
                },
              },
              {
                poster: {
                  src: "https://images-na.ssl-images-amazon.com/images/M/MV5BNDIxNzUxMzk1NF5BMl5BanBnXkFtZTgwNzA5NjAzNjE@.jpg",
                  alt: "Million Dollar Listing on Bravo",
                },
                channel: {
                  name: "Bravo",
                  logo: {
                    src: "http://vignette3.wikia.nocookie.net/logopedia/images/3/3e/Bravo_TV.svg",
                    alt: "Bravo Logo",
                  },
                },
              },
            ];
          }

          function _calcDimensions() {
            var slides = scope.slidesContainer.children();
            var slide = slides.length > 0 ? slides[0] : null;
            var slideWidth = slide ? slide.getBoundingClientRect().width : 0;
            var slideTotal = scope.slides.length;
            scope.animatorWidth = slideWidth * slideTotal;
          }

          function _init() {
            _getChannelData();
            _bindEvents();
          }

          _init();
        },
      };
    }

    function CarouselSlide() {
      return {
        scope: {
          slide: "=",
          duplicate: "@",
        },
        restrict: "E",
        replace: true,
        template:
          '<div class="carousel-slide" ng-class="getSlideClasses()"><img ng-src="{{slide.poster.src}}" alt="{{slide.poster.alt}}" class="poster"/><div class="channel-info-bar"><div class="cell"><img ng-src="{{slide.channel.logo.src}}" alt="{{slide.channel.logo.alt}}" class="channel-logo"/></div><div class="cell"><h6 class="channel-name">{{slide.channel.name}}</h6></div></div></div>',
        link: function (scope) {
          scope.getSlideClasses = function () {
            return {
              duplicate: scope.duplicate,
              before: scope.duplicate === "before",
              after: scope.duplicate === "after",
            };
          };
        },
      };
    }
  })(angular, Impetus);
</script>
